#include "app_api.h"
#include "vesa_driver.h"

void operator delete(void*, unsigned int) {}
void operator delete(void*) {}
extern "C" void __cxa_pure_virtual() {
    vlsmc::App::print("Pure virtual function call!\n");
    vlsmc::App::exit(1);
}

using namespace vlsmc;

namespace {

// Public-domain style 8x8 ASCII font (0..127)
static const uint8_t FONT8X8[128][8] = {
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},{0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00},
{0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00},{0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00},
{0x18,0x3E,0x03,0x1E,0x30,0x1F,0x18,0x00},{0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00},
{0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00},{0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00},
{0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00},{0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00},
{0x00,0x66,0x3C,0x7F,0x3C,0x66,0x00,0x00},{0x00,0x0C,0x0C,0x3F,0x0C,0x0C,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x06},{0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00},{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00},
{0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00},{0x0C,0x0E,0x0C,0x0C,0x0C,0x0C,0x3F,0x00},
{0x1E,0x33,0x30,0x1C,0x06,0x33,0x3F,0x00},{0x1E,0x33,0x30,0x1C,0x30,0x33,0x1E,0x00},
{0x38,0x3C,0x36,0x33,0x7F,0x30,0x78,0x00},{0x3F,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00},
{0x1C,0x06,0x03,0x1F,0x33,0x33,0x1E,0x00},{0x3F,0x33,0x30,0x18,0x0C,0x0C,0x0C,0x00},
{0x1E,0x33,0x33,0x1E,0x33,0x33,0x1E,0x00},{0x1E,0x33,0x33,0x3E,0x30,0x18,0x0E,0x00},
{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00},{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x06},
{0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x00},{0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00},
{0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00},{0x1E,0x33,0x30,0x18,0x0C,0x00,0x0C,0x00},
{0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00},{0x0C,0x1E,0x33,0x33,0x3F,0x33,0x33,0x00},
{0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00},{0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00},
{0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00},{0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00},
{0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00},{0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00},
{0x33,0x33,0x33,0x3F,0x33,0x33,0x33,0x00},{0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},
{0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00},{0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00},
{0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00},{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00},
{0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00},{0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00},
{0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00},{0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00},
{0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00},{0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00},
{0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},{0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00},
{0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00},{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00},{0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00},
{0x7F,0x73,0x19,0x0C,0x26,0x63,0x7F,0x00},{0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00},
{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},{0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00},
{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
{0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00},
{0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00},{0x00,0x00,0x1E,0x33,0x03,0x33,0x1E,0x00},
{0x38,0x30,0x30,0x3E,0x33,0x33,0x6E,0x00},{0x00,0x00,0x1E,0x33,0x3F,0x03,0x1E,0x00},
{0x1C,0x36,0x06,0x0F,0x06,0x06,0x0F,0x00},{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F},
{0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00},{0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00},
{0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1E},{0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00},
{0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},{0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00},
{0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00},{0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00},
{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F},{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78},
{0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00},{0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00},
{0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00},{0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00},
{0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00},{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00},
{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00},{0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F},
{0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00},{0x38,0x0C,0x0C,0x07,0x0C,0x0C,0x38,0x00},
{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00},{0x07,0x0C,0x0C,0x38,0x0C,0x0C,0x07,0x00},
{0x6E,0x3B,0x00,0x00,0x00,0x00,0x00,0x00},{0,0,0,0,0,0,0,0},

// Remaining control chars 96..127 unused fallback to empty/simple
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}
};

static const int SCREEN_W = 1024;
static const int SCREEN_H = 768;
static const int CHAR_W = 8;
static const int CHAR_H = 8;

static const int TOP_BAR_H = 20;
static const int STATUS_H = 20;
static const int TEXT_X = 8;
static const int TEXT_Y = TOP_BAR_H + 4;
static const int TEXT_W = (SCREEN_W - 16) / CHAR_W;
static const int TEXT_H = (SCREEN_H - TOP_BAR_H - STATUS_H - 8) / CHAR_H;

static const int MAX_TEXT = 128 * 1024;
static char text_buf[MAX_TEXT];
static int text_len = 0;
static int cursor = 0;
static int view_line = 0;
static bool modified = false;
static const char* FILE_PATH = "/EDIT.TXT";

void mem_move(char* dst, const char* src, int n) {
    if (n <= 0 || dst == src) return;
    if (dst < src) {
        for (int i = 0; i < n; i++) dst[i] = src[i];
    } else {
        for (int i = n - 1; i >= 0; i--) dst[i] = src[i];
    }
}

int str_len(const char* s) {
    int n = 0;
    while (s && s[n]) n++;
    return n;
}

void fill_rect(VesaDriver& drv, int x, int y, int w, int h, uint32_t color) {
    if (x < 0) { w += x; x = 0; }
    if (y < 0) { h += y; y = 0; }
    if (x + w > SCREEN_W) w = SCREEN_W - x;
    if (y + h > SCREEN_H) h = SCREEN_H - y;
    if (w <= 0 || h <= 0) return;

    for (int yy = 0; yy < h; yy++) {
        for (int xx = 0; xx < w; xx++) {
            drv.draw_pixel((uint32_t)(x + xx), (uint32_t)(y + yy), color);
        }
    }
}

void draw_char(VesaDriver& drv, int cx, int cy, char ch, uint32_t fg, uint32_t bg) {
    uint8_t idx = (uint8_t)ch;
    const uint8_t* g = FONT8X8[idx];
    int px = TEXT_X + cx * CHAR_W;
    int py = TEXT_Y + cy * CHAR_H;

    for (int y = 0; y < 8; y++) {
        uint8_t bits = g[y];
        for (int x = 0; x < 8; x++) {
            bool on = (bits & (1u << x)) != 0;
            drv.draw_pixel((uint32_t)(px + x), (uint32_t)(py + y), on ? fg : bg);
        }
    }
}

void draw_text(VesaDriver& drv, int px, int py, const char* s, uint32_t fg, uint32_t bg) {
    int x = px;
    for (int i = 0; s[i]; i++) {
        uint8_t idx = (uint8_t)s[i];
        const uint8_t* g = FONT8X8[idx];
        for (int y = 0; y < 8; y++) {
            uint8_t bits = g[y];
            for (int xx = 0; xx < 8; xx++) {
                bool on = (bits & (1u << xx)) != 0;
                drv.draw_pixel((uint32_t)(x + xx), (uint32_t)(py + y), on ? fg : bg);
            }
        }
        x += 8;
    }
}

void index_to_linecol(int idx, int& line, int& col) {
    line = 0;
    col = 0;
    for (int i = 0; i < idx && i < text_len; i++) {
        if (text_buf[i] == '\n') { line++; col = 0; }
        else col++;
    }
}

int linecol_to_index(int target_line, int target_col) {
    int line = 0;
    int col = 0;
    for (int i = 0; i < text_len; i++) {
        if (line == target_line && col == target_col) return i;
        if (text_buf[i] == '\n') {
            if (line == target_line) return i;
            line++; col = 0;
        } else {
            col++;
        }
    }
    return text_len;
}

void ensure_cursor_visible() {
    int line, col;
    index_to_linecol(cursor, line, col);
    (void)col;
    if (line < view_line) view_line = line;
    if (line >= view_line + TEXT_H) view_line = line - TEXT_H + 1;
    if (view_line < 0) view_line = 0;
}

void insert_char(char c) {
    if (text_len >= MAX_TEXT - 1) return;
    mem_move(text_buf + cursor + 1, text_buf + cursor, text_len - cursor);
    text_buf[cursor] = c;
    cursor++;
    text_len++;
    modified = true;
}

void backspace_char() {
    if (cursor <= 0) return;
    mem_move(text_buf + cursor - 1, text_buf + cursor, text_len - cursor);
    cursor--;
    text_len--;
    modified = true;
}

void delete_char() {
    if (cursor >= text_len) return;
    mem_move(text_buf + cursor, text_buf + cursor + 1, text_len - cursor - 1);
    text_len--;
    modified = true;
}

bool load_file() {
    int fd = App::open(FILE_PATH, FMODE_READ);
    if (fd < 0) {
        text_len = 0;
        cursor = 0;
        modified = false;
        return false;
    }

    int got = App::read(fd, text_buf, MAX_TEXT - 1);
    App::close(fd);

    if (got < 0) {
        text_len = 0;
        cursor = 0;
        modified = false;
        return false;
    }

    text_len = got;
    cursor = 0;
    modified = false;
    return true;
}

bool save_file() {
    int fd = App::open(FILE_PATH, FMODE_WRITE);
    if (fd < 0) return false;
    int wr = App::write(fd, text_buf, (uint32_t)text_len);
    App::close(fd);
    if (wr < 0) return false;
    modified = false;
    return true;
}

char map_scancode(uint8_t sc, bool shift) {
    static const char normal[58] = {
        0,
        27,'1','2','3','4','5','6','7','8','9','0','-','=', '\b',
        '\t','q','w','e','r','t','y','u','i','o','p','[',']','\n',
        0,'a','s','d','f','g','h','j','k','l',';', '\'', '`',
        0,'\\','z','x','c','v','b','n','m',',','.','/',0,
        '*',0,' '
    };

    static const char shifted[58] = {
        0,
        27,'!','@','#','$','%','^','&','*','(',')','_','+', '\b',
        '\t','Q','W','E','R','T','Y','U','I','O','P','{','}','\n',
        0,'A','S','D','F','G','H','J','K','L',':', '"', '~',
        0,'|','Z','X','C','V','B','N','M','<','>','?',0,
        '*',0,' '
    };

    if (sc >= 58) return 0;
    return shift ? shifted[sc] : normal[sc];
}

void draw_editor(VesaDriver& drv, bool save_ok, bool loaded_ok) {
    fill_rect(drv, 0, 0, SCREEN_W, SCREEN_H, 0xFF101418);

    fill_rect(drv, 0, 0, SCREEN_W, TOP_BAR_H, 0xFF202A36);
    draw_text(drv, 8, 6, "GFXEDIT - F2 Save | ESC Quit | Arrows Move", 0xFFFFFFFF, 0xFF202A36);

    fill_rect(drv, 0, SCREEN_H - STATUS_H, SCREEN_W, STATUS_H, 0xFF202A36);
    draw_text(drv, 8, SCREEN_H - STATUS_H + 6, FILE_PATH, 0xFF8BE9FD, 0xFF202A36);
    draw_text(drv, 220, SCREEN_H - STATUS_H + 6, modified ? "[modified]" : "[saved]", modified ? 0xFFFFB86C : 0xFF50FA7B, 0xFF202A36);
    draw_text(drv, 340, SCREEN_H - STATUS_H + 6, loaded_ok ? "load:ok" : "load:new", 0xFFBD93F9, 0xFF202A36);
    draw_text(drv, 430, SCREEN_H - STATUS_H + 6, save_ok ? "save:ok" : "save:--", 0xFF50FA7B, 0xFF202A36);

    int cur_line = 0, cur_col = 0;
    index_to_linecol(cursor, cur_line, cur_col);

    int line = 0;
    int col = 0;
    int screen_line = 0;

    for (int i = 0; i <= text_len; i++) {
        bool end = (i == text_len);
        char ch = end ? '\0' : text_buf[i];

        if (line >= view_line && screen_line < TEXT_H) {
            if (!end && ch != '\n' && col < TEXT_W) {
                draw_char(drv, col, screen_line, ch, 0xFFE6E6E6, 0xFF101418);
            }
        }

        if (end || ch == '\n') {
            if (line >= view_line) screen_line++;
            line++;
            col = 0;
            if (screen_line >= TEXT_H) break;
        } else {
            col++;
        }
    }

    int cy = cur_line - view_line;
    if (cy >= 0 && cy < TEXT_H && cur_col >= 0 && cur_col < TEXT_W) {
        int px = TEXT_X + cur_col * CHAR_W;
        int py = TEXT_Y + cy * CHAR_H;
        fill_rect(drv, px, py + 7, 8, 1, 0xFFFFFF00);
    }
}

} // namespace

int main() {
    VesaDriver drv;
    DriverContext ctx{};
    if (drv.init(&ctx) != 0) {
        App::print("GFXEDIT: VESA init failed\n");
        return 1;
    }

    bool loaded_ok = load_file();
    bool save_ok = false;
    bool shift = false;
    bool ext = false;

    while (true) {
        draw_editor(drv, save_ok, loaded_ok);

        while ((App::inb(0x64) & 0x01) != 0) {
            uint8_t sc = App::inb(0x60);

            if (sc == 0xE0) { ext = true; continue; }

            bool release = (sc & 0x80) != 0;
            uint8_t code = sc & 0x7F;

            if (code == 0x2A || code == 0x36) { // shift
                shift = !release;
                ext = false;
                continue;
            }

            if (release) { ext = false; continue; }

            if (ext) {
                // arrows + delete
                int line, col;
                index_to_linecol(cursor, line, col);
                if (code == 0x48) { // up
                    if (line > 0) cursor = linecol_to_index(line - 1, col);
                } else if (code == 0x50) { // down
                    cursor = linecol_to_index(line + 1, col);
                } else if (code == 0x4B) { // left
                    if (cursor > 0) cursor--;
                } else if (code == 0x4D) { // right
                    if (cursor < text_len) cursor++;
                } else if (code == 0x53) {
                    delete_char();
                }
                ext = false;
                ensure_cursor_visible();
                continue;
            }

            if (code == 0x01) { // ESC
                drv.stop(&ctx);
                App::print("GFXEDIT: exit\n");
                return 0;
            }
            if (code == 0x3C) { // F2
                save_ok = save_file();
                continue;
            }

            if (code == 0x0E) {
                backspace_char();
            } else if (code == 0x1C) {
                insert_char('\n');
            } else if (code == 0x4B) {
                if (cursor > 0) cursor--;
            } else if (code == 0x4D) {
                if (cursor < text_len) cursor++;
            } else {
                char c = map_scancode(code, shift);
                if (c >= 32 || c == '\t') insert_char(c);
            }

            ensure_cursor_visible();
        }

        App::sleep(12);
    }

    return 0;
}
