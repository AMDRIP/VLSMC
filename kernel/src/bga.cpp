#include "kernel/bga.h"
#include "kernel/pci.h"
#include "kernel/vmm.h"
#include "kernel/pic.h" // For inw/outw
#include "libc.h"

#define VBE_DISPI_IOPORT_INDEX 0x01CE
#define VBE_DISPI_IOPORT_DATA  0x01CF

#define VBE_DISPI_INDEX_ID           0x0
#define VBE_DISPI_INDEX_XRES         0x1
#define VBE_DISPI_INDEX_YRES         0x2
#define VBE_DISPI_INDEX_BPP          0x3
#define VBE_DISPI_INDEX_ENABLE       0x4
#define VBE_DISPI_INDEX_BANK         0x5
#define VBE_DISPI_INDEX_VIRT_WIDTH   0x6
#define VBE_DISPI_INDEX_VIRT_HEIGHT  0x7
#define VBE_DISPI_INDEX_X_OFFSET     0x8
#define VBE_DISPI_INDEX_Y_OFFSET     0x9

#define VBE_DISPI_DISABLED           0x00
#define VBE_DISPI_ENABLED            0x01
#define VBE_DISPI_LFB_ENABLED        0x40
#define VBE_DISPI_NOCLEARMEM         0x80

namespace re36 {

bool BgaDriver::initialized_ = false;
uint16_t BgaDriver::width_ = 0;
uint16_t BgaDriver::height_ = 0;
uint16_t BgaDriver::bpp_ = 0;
uint32_t BgaDriver::pitch_ = 0;

uint32_t BgaDriver::framebuffer_phys_ = 0;
uint32_t BgaDriver::framebuffer_virt_ = 0x00400000; // Directly after the first 4MB of Kernel Space
uint32_t BgaDriver::framebuffer_size_ = 0;

static const uint8_t font8x8[128][8] = {
    {0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},
    {0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},{0},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    {0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x00},
    {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00},
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00},
    {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00},
    {0x62,0x66,0x0C,0x18,0x30,0x66,0x46,0x00},
    {0x3C,0x66,0x3C,0x38,0x67,0x66,0x3F,0x00},
    {0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00},
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00},
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00},
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00},
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30},
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},
    {0x02,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},
    {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},
    {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00},
    {0x3C,0x66,0x06,0x0C,0x18,0x30,0x7E,0x00},
    {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},
    {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},
    {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
    {0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00},
    {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},
    {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},
    {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},
    {0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00},
    {0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x00},
    {0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00},
    {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00},
    {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00},
    {0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00},
    {0x3C,0x66,0x6E,0x6A,0x6E,0x60,0x3E,0x00},
    {0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00},
    {0x7C,0x66,0x66,0x7C,0x66,0x66,0x7C,0x00},
    {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
    {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00},
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x7E,0x00},
    {0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x00},
    {0x3E,0x60,0x60,0x6E,0x66,0x66,0x3E,0x00},
    {0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00},
    {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
    {0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00},
    {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00},
    {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00},
    {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00},
    {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00},
    {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00},
    {0x3C,0x66,0x66,0x66,0x6A,0x6C,0x36,0x00},
    {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00},
    {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
    {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
    {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
    {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00},
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00},
    {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00},
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00},
    {0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00},
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00},
    {0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
    {0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00},
    {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00},
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00},
    {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00},
    {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00},
    {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00},
    {0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00},
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C},
    {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00},
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
    {0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x38},
    {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00},
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
    {0x00,0x00,0x66,0x7F,0x6B,0x63,0x63,0x00},
    {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00},
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00},
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60},
    {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06},
    {0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00},
    {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00},
    {0x30,0x30,0x7C,0x30,0x30,0x30,0x1C,0x00},
    {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00},
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00},
    {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00},
    {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00},
    {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C},
    {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00},
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00},
    {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00},
    {0x00,0x00,0x32,0x7F,0x4C,0x00,0x00,0x00},
    {0}
};

// inw/outw are included from kernel/pic.h

void BgaDriver::write_register(uint16_t index, uint16_t val) {
    outw(VBE_DISPI_IOPORT_INDEX, index);
    outw(VBE_DISPI_IOPORT_DATA, val);
}

uint16_t BgaDriver::read_register(uint16_t index) {
    outw(VBE_DISPI_IOPORT_INDEX, index);
    return inw(VBE_DISPI_IOPORT_DATA);
}

void BgaDriver::init(uint16_t width, uint16_t height, uint16_t bpp) {
    printf("[BGA] Initializing Bochs Graphics Adapter...\n");

    // 1. Find the BGA device on the PCI bus
    PCIDevice* devices = PCI::get_devices();
    int count = PCI::get_device_count();
    PCIDevice* info = nullptr;
    
    for (int i = 0; i < count; i++) {
        if (devices[i].vendor_id == 0x1234 && devices[i].device_id == 0x1111) {
            info = &devices[i];
            break;
        }
    }

    if (!info) {
        printf("[BGA] Error: QEMU/Bochs VGA (0x1234:0x1111) not found on PCI bus!\n");
        return;
    }

    // 2. Extract BAR0 (Physical Address of the Framebuffer)
    uint32_t bar0 = PCI::config_read_dword(info->bus, info->slot, info->func, 0x10);
    framebuffer_phys_ = bar0 & 0xFFFFFFF0; // Strip lower flag bits

    if (framebuffer_phys_ == 0) {
        printf("[BGA] Error: BAR0 is 0. Framebuffer physical address is invalid.\n");
        return;
    }

    width_ = width;
    height_ = height;
    bpp_ = bpp;
    pitch_ = (width * bpp) / 8; // Default calculation, BGA will enforce this as virtual width
    
    // Calculate total memory needed
    framebuffer_size_ = pitch_ * height_;

    // 3. Map the Framebuffer in VMM
    printf("[BGA] Mapping %d bytes at Phys: 0x%x to Virt: 0x%x\n", 
           framebuffer_size_, framebuffer_phys_, framebuffer_virt_);
           
    for (uint32_t i = 0; i < framebuffer_size_; i += PAGE_SIZE) {
        VMM::map_page(framebuffer_virt_ + i, framebuffer_phys_ + i, PAGE_PRESENT | PAGE_WRITABLE);
    }

    // 4. Configure BGA Registers (Crucial steps to avoid artifacting and bugs)
    
    // CRITICAL: Disable the BGA before attempting to change settings
    write_register(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_DISABLED);

    write_register(VBE_DISPI_INDEX_XRES, width_);
    write_register(VBE_DISPI_INDEX_YRES, height_);
    write_register(VBE_DISPI_INDEX_VIRT_WIDTH, width_);
    write_register(VBE_DISPI_INDEX_BPP, bpp_);
    write_register(VBE_DISPI_INDEX_X_OFFSET, 0);
    write_register(VBE_DISPI_INDEX_Y_OFFSET, 0);

    // Enable BGA and Linear Framebuffer
    write_register(VBE_DISPI_INDEX_ENABLE, VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);

    // Verify Virtual Width to correct our Pitch
    uint16_t actual_virt_width = read_register(VBE_DISPI_INDEX_VIRT_WIDTH);
    pitch_ = actual_virt_width * (bpp_ / 8);

    printf("[BGA] Enabled mode %dx%d %dbpp (Pitch: %d)\n", width_, height_, bpp_, pitch_);
    
    initialized_ = true;
}

void BgaDriver::put_pixel(uint32_t x, uint32_t y, uint32_t color) {
    if (x >= width_ || y >= height_) return;
    
    // CRITICAL: Use pitch and bytes_per_pixel, not `y * width`
    uint32_t offset = (y * pitch_) + (x * (bpp_ / 8));
    
    uint8_t* fb = (uint8_t*)framebuffer_virt_;
    if (bpp_ == 32) {
        *(uint32_t*)(fb + offset) = color; // Write 4 bytes directly
    } else if (bpp_ == 24) {
        fb[offset] = color & 0xFF;
        fb[offset + 1] = (color >> 8) & 0xFF;
        fb[offset + 2] = (color >> 16) & 0xFF;
    } else if (bpp_ == 16) {
        *(uint16_t*)(fb + offset) = (uint16_t)color;
    }
}

void BgaDriver::clear_screen(uint32_t color) {
    if (bpp_ == 32) {
        uint32_t* fb32 = (uint32_t*)framebuffer_virt_;
        int total_pixels = (pitch_ * height_) / 4;
        for (int i = 0; i < total_pixels; i++) {
            fb32[i] = color;
        }
    } else {
        for (uint32_t y = 0; y < height_; y++) {
            for (uint32_t x = 0; x < width_; x++) {
                put_pixel(x, y, color);
            }
        }
    }
}

void BgaDriver::draw_char(uint32_t x, uint32_t y, char c, uint32_t fg_color, uint32_t bg_color) {
    uint8_t idx = (uint8_t)c;
    if (idx >= 128) idx = '?';
    const uint8_t* glyph = font8x8[idx];

    for (int row = 0; row < 8; row++) {
        uint8_t bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            uint32_t color = (bits & (0x80 >> col)) ? fg_color : bg_color;
            put_pixel(x + col, y + row, color);
        }
    }
}

void BgaDriver::scroll(uint32_t lines, uint32_t bg_color) {
    if (!initialized_) return;
    
    uint32_t pixels_to_scroll = lines * 8; // Assuming 8px height per text line
    if (pixels_to_scroll >= height_) {
        clear_screen(bg_color);
        return;
    }

    uint8_t* fb = (uint8_t*)framebuffer_virt_;
    uint32_t bytes_to_copy = (height_ - pixels_to_scroll) * pitch_;
    uint32_t scroll_offset = pixels_to_scroll * pitch_;

    // Fast memory move to slide everything up
    // Must handle overlapping memory regions safely, standard memcpy is fine since dest < src
    for (uint32_t i = 0; i < bytes_to_copy; i++) {
        fb[i] = fb[i + scroll_offset];
    }

    // Clear the bottom lines
    uint32_t clear_start = bytes_to_copy;
    uint32_t clear_end = height_ * pitch_;
    
    if (bpp_ == 32) {
        uint32_t* fb32 = (uint32_t*)fb;
        for (uint32_t i = clear_start / 4; i < clear_end / 4; i++) {
            fb32[i] = bg_color;
        }
    } else {
        // Fallback for bpp == 24/16
        for (uint32_t y = height_ - pixels_to_scroll; y < height_; y++) {
            for (uint32_t x = 0; x < width_; x++) {
                put_pixel(x, y, bg_color);
            }
        }
    }
}

} // namespace re36
