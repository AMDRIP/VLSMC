# Дорожная карта реализации сетевого стека (Network Stack)

Этот документ описывает пошаговый алгоритм реализации сетевой подсистемы VLSMC, от драйверов устройств до сокетов пользовательского уровня.

## Архитектурные принципы

1.  **Zero-Copy (по возможности)**: Использование цепочек буферов для минимизации копирования данных между слоями.
2.  **Асинхронность**: Обработка пакетов в контексте прерываний (Bottom Half) или отдельном потоке ядра, чтобы не блокировать систему.
3.  **Модульность**: Четкое разделение уровней L2 (Ethernet), L3 (IP), L4 (TCP/UDP).
4.  **Endianness**: Все поля заголовков в сети — Big Endian (Network Byte Order). Ядро должно использовать функции `htons`, `htonl`, `ntohs`, `ntohl`.

---

## Этап 1: Управление памятью (Packet Buffers)

Создание структуры данных для хранения сетевых пакетов, аналогичной `sk_buff` в Linux или `mbuf` в BSD.

*   **Требования**:
    *   Структура `NetBuffer`: указатель на сырые данные, размер, смещение начала данных (headroom) для добавления заголовков без копирования.
    *   Поддержка цепочек (Linked List) для фрагментированных пакетов.
*   **Граничные условия**:
    *   Исчерпание памяти (OOM) при шторме пакетов.
    *   Утечки памяти при отбрасывании пакетов на промежуточных уровнях.

## Этап 2: Драйвер сетевой карты (NIC) — RTL8139 / E1000

Реализация драйвера для QEMU (обычно RTL8139 или Intel E1000).

*   **Требования**:
    *   Инициализация PCI устройства (Bus Mastering).
    *   Настройка DMA кольцевых буферов (RX/TX Rings).
    *   Обработка прерываний: чтение статуса, копирование данных из DMA-буфера в `NetBuffer`, очистка флага прерывания.
*   **Граничные условия**:
    *   **RX Overflow**: Кольцевой буфер переполнен (драйвер должен дропать пакеты и вести счетчик ошибок).
    *   **TX Busy**: Попытка отправки, когда TX-буфер полон (очередь или блокировка).
    *   **Spurious Interrupts**: Прерывания без событий.

## Этап 3: Ethernet (L2) и Loopback

Обработка кадров Ethernet II.

*   **Требования**:
    *   Парсинг заголовка Ethernet (Source MAC, Dest MAC, EtherType).
    *   Проверка MAC-адреса: принимать только Unicast (свой MAC) и Broadcast (`FF:FF:FF:FF:FF:FF`).
    *   Демультиплексирование по EtherType: `0x0806` (ARP), `0x0800` (IPv4).
*   **Граничные условия**:
    *   Пакеты меньше 64 байт (Runt frames) — должны отбрасываться (если NIC не делает это сам).
    *   Пакеты больше MTU (обычно 1500) — отбрасывать (Jumbo frames пока не поддерживаем).

## Этап 4: ARP (Address Resolution Protocol)

Преобразование IP-адресов в MAC-адреса.

*   **Требования**:
    *   **ARP Table**: Кэш соответствия `IP -> MAC` с временем жизни (TTL).
    *   **ARP Request**: Если MAC неизвестен, отправить широковещательный запрос, поставить исходящий пакет в очередь ожидания.
    *   **ARP Reply**: Ответ на запросы к своему IP.
*   **Граничные условия**:
    *   **ARP Storm**: Ограничение частоты ответов.
    *   Переполнение таблицы ARP (вытеснение старых записей LRU).
    *   Gratuitous ARP (обновление кэша при смене IP).

## Этап 5: IP (Internet Protocol v4)

Маршрутизация и обработка пакетов сетевого уровня.

*   **Требования**:
    *   Проверка версии (4), длины заголовка (IHL), контрольной суммы заголовка.
    *   Проверка TTL: декремент, если 0 — отправить ICMP Time Exceeded.
    *   Маршрутизация: определение интерфейса для отправки (пока только один + Loopback).
*   **Граничные условия**:
    *   **Фрагментация**: Сборка фрагментированных пакетов (Reassembly). Опасное место (Teardrop attack, переполнение буфера сборки). *Для MVP можно дропать фрагменты.*
    *   Пакеты не нам (если не включен IP Forwarding — дропать).

## Этап 6: ICMP (Internet Control Message Protocol)

Диагностика сети.

*   **Требования**:
    *   Обработка `Echo Request` (Ping) -> отправка `Echo Reply`.
    *   Генерация `Destination Unreachable` (если порт UDP/TCP закрыт).
*   **Граничные условия**:
    *   Не отвечать на ICMP ошибки (чтобы избежать бесконечных циклов).
    *   Не отвечать на Broadcast Ping (защита от Smurf attack).

## Этап 7: UDP (User Datagram Protocol)

Простой транспортный протокол без установления соединения.

*   **Требования**:
    *   Таблица прослушиваемых портов (Bind table).
    *   Проверка контрольной суммы (включая Pseudo Header).
    *   Передача данных в сокет приложения.
*   **Граничные условия**:
    *   Порт закрыт: отправка ICMP Port Unreachable.
    *   Checksum = 0: в UDP это означает "нет контрольной суммы" (разрешено), но если вычисленная сумма 0, она записывается как 0xFFFF.

## Этап 8: TCP (Transmission Control Protocol) — Базовый

Самый сложный этап. Реализация конечного автомата (State Machine).

*   **Требования**:
    *   **Handshake**: SYN -> SYN-ACK -> ACK.
    *   **States**: LISTEN, SYN_RCVD, ESTABLISHED, CLOSE_WAIT, etc.
    *   **Sequence Numbers**: Отслеживание SEQ и ACK номеров.
    *   **Window**: Управление окном приема (Flow Control).
*   **Граничные условия**:
    *   **SYN Flood**: Защита очереди полуоткрытых соединений (SYN Cookies).
    *   **RST**: Обработка сброса соединения.
    *   Потеря пакетов: Таймеры ретрансмиссии (Retransmission Timer).

## Этап 9: TCP — Продвинутый (Congestion Control)

Оптимизация производительности TCP.

*   **Требования**:
    *   Алгоритмы Slow Start, Congestion Avoidance.
    *   Fast Retransmit (по дубликатам ACK).
    *   Delayed ACK (отложенное подтверждение).
*   **Граничные условия**:
    *   Silly Window Syndrome (отправка слишком мелких пакетов).
    *   Zero Window Probe (опрос, когда окно получателя закрылось).

## Этап 10: Socket API и Системные вызовы

Предоставление интерфейса для User Space (Ring 3).

*   **Системные вызовы**:
    *   `socket(domain, type, protocol)` -> возвращает файловый дескриптор (FD).
    *   `bind(fd, addr, len)`
    *   `connect(fd, addr, len)`
    *   `listen(fd, backlog)`
    *   `accept(fd, addr, len)` -> блокирующий вызов.
    *   `send/recv` и `sendto/recvfrom`.
*   **Интеграция с VFS**:
    *   Сокеты должны вести себя как файлы (поддержка `close`, `read`, `write`, `ioctl`).
*   **Граничные условия**:
    *   Блокирующие vs Неблокирующие сокеты (`O_NONBLOCK`).
    *   `SIGPIPE` при записи в закрытый сокет.
    *   Корректное закрытие сокетов при завершении процесса (`sys_exit`).

---

## Рекомендуемый порядок тестирования
1.  Loopback (ping 127.0.0.1).
2.  ARP (виден ли MAC в сниффере QEMU).
3.  ICMP Ping с хоста на гостевую ОС.
4.  UDP Echo сервер.
5.  TCP HTTP сервер (статическая страница).