# Технические требования: Драйвер файловой системы FAT32

Этот документ описывает спецификацию реализации драйвера FAT32 для VLSMC, включая особенности работы со структурой на диске, алгоритмы адресации и интеграцию с подсистемой VFS.

## 1. Определение и Идентификация

Драйвер не должен полагаться на строку "FAT32" в загрузочном секторе. Тип FAT определяется исключительно по количеству кластеров данных:

*   **FAT12**: < 4085 кластеров
*   **FAT16**: 4085 – 65524 кластеров
*   **FAT32**: >= 65525 кластеров

Формула подсчета кластеров:
```c
RootDirSectors = ((BPB_RootEntCnt * 32) + (BPB_BytsPerSec - 1)) / BPB_BytsPerSec;
FATSz = (BPB_FATSz16 != 0) ? BPB_FATSz16 : BPB_FATSz32;
TotalSectors = (BPB_TotSec16 != 0) ? BPB_TotSec16 : BPB_TotSec32;
DataSectors = TotalSectors - (BPB_RsvdSecCnt + (BPB_NumFATs * FATSz) + RootDirSectors);
CountOfClusters = DataSectors / BPB_SecPerClus;
```

## 2. Структура BPB (BIOS Parameter Block)

Для FAT32 используется расширенная структура EBPB, начинающаяся со смещения `0x24` (сразу после стандартного BPB).

| Смещение | Размер | Имя поля | Описание |
|:---|:---|:---|:---|
| 0x0B | 2 | `BPB_BytsPerSec` | Байт в секторе (обычно 512). |
| 0x0D | 1 | `BPB_SecPerClus` | Секторов в кластере (степень двойки). |
| 0x0E | 2 | `BPB_RsvdSecCnt` | Резервные сектора (для FAT32 обычно 32). |
| 0x10 | 1 | `BPB_NumFATs` | Количество таблиц FAT (обычно 2). |
| 0x24 | 4 | `BPB_FATSz32` | Размер одной FAT в секторах. |
| 0x28 | 2 | `BPB_ExtFlags` | Флаги (бит 7: 0=FAT зеркалируются, 1=активна только одна; биты 0-3: номер активной FAT). |
| 0x2C | 4 | `BPB_RootClus` | Номер первого кластера корневой директории (обычно 2). |
| 0x30 | 2 | `BPB_FSInfo` | Номер сектора структуры FSInfo (обычно 1). |

## 3. Таблица размещения файлов (FAT)

### 3.1. Формат записей
В FAT32 каждая запись занимает **32 бита** (4 байта).
> [!WARNING]
> **Верхние 4 бита зарезервированы!**
> При чтении значения кластера необходимо применять маску `0x0FFFFFFF`. При записи нового значения необходимо **сохранять** старые верхние 4 бита (обычно нули, но спецификация требует их не трогать).

### 3.2. Специальные значения (после маски)
*   `0x00000000`: Свободный кластер.
*   `0x00000001`: Зарезервировано (не использовать).
*   `0x00000002` — `0x0FFFFFEF`: Используемые кластеры данных.
*   `0x0FFFFFF0` — `0x0FFFFFF6`: Зарезервировано.
*   `0x0FFFFFF7`: Поврежденный кластер (Bad Cluster).
*   `0x0FFFFFF8` — `0x0FFFFFFF`: Конец цепочки (EOC / End Of Chain).

## 4. Адресация данных

В отличие от FAT12/16, у FAT32 нет фиксированной области корневой директории. Корневая директория — это обычная цепочка кластеров.

### 4.1. Расчет LBA
```c
// Начало области данных (сразу после всех FAT)
FirstDataSector = BPB_RsvdSecCnt + (BPB_NumFATs * BPB_FATSz32);

// Преобразование номера кластера N в LBA сектор
LBA(N) = FirstDataSector + ((N - 2) * BPB_SecPerClus);
```

### 4.2. Чтение FAT таблицы
Чтобы узнать следующий кластер для кластера `N`:
1. `FATOffset = N * 4`
2. `ThisFATSecNum = BPB_RsvdSecCnt + (FATOffset / BPB_BytsPerSec)`
3. `ThisFATEntOffset = FATOffset % BPB_BytsPerSec`
4. Прочитать сектор `ThisFATSecNum`.
5. Взять `uint32_t` по смещению `ThisFATEntOffset`.
6. Применить маску `& 0x0FFFFFFF`.

## 5. Структура FSInfo

Для ускорения поиска свободных кластеров FAT32 использует специальный сектор FSInfo (обычно сектор 1).

| Смещение | Размер | Значение | Описание |
|:---|:---|:---|:---|
| 0x00 | 4 | `0x41615252` | Lead Signature (`RRaA`) |
| 0x1E4 | 4 | `0x61417272` | Struct Signature (`rrAa`) |
| 0x1E8 | 4 | `Free_Count` | Кол-во свободных кластеров (или 0xFFFFFFFF, если неизвестно) |
| 0x1EC | 4 | `Nxt_Free` | Номер первого доступного кластера (подсказка для аллокатора) |
| 0x1FE | 2 | `0xAA55` | Boot Signature |

**Требования к драйверу:**
1. При монтировании читать FSInfo.
2. При аллокации начинать поиск с `Nxt_Free`.
3. При записи/удалении обновлять `Free_Count` и `Nxt_Free` в памяти и сбрасывать на диск.
4. Если значения равны `0xFFFFFFFF`, необходимо пересчитать их полным сканированием FAT.

## 6. Работа с директориями и LFN

### 6.1. Формат 8.3 (Short File Name)
Стандартная запись 32 байта. Идентична FAT16.
*   В FAT32 верхние 2 байта поля `FirstClusterHigh` (смещение 0x14) используются вместе с `FirstClusterLow` (смещение 0x1A) для формирования 32-битного номера кластера.

### 6.2. Long File Names (VFAT)
VLSMC должна корректно обрабатывать LFN записи, чтобы не отображать их как мусорные файлы.
*   **Идентификация**: Атрибут `ATTR_LONG_NAME` = `ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID` (`0x0F`).
*   **Действие**: Драйвер должен либо игнорировать такие записи (MVP), либо собирать их в буфер для формирования длинного имени (Target).
*   **Checksum**: LFN записи привязаны к следующей за ними 8.3 записи через контрольную сумму.

## 7. Интеграция с VFS (vfs_filesystem_driver)

Драйвер должен реализовать следующие методы:

1.  **`mount`**:
    *   Прочитать сектор 0.
    *   Проверить сигнатуры и тип FAT (по кол-ву кластеров).
    *   Прочитать FSInfo.
    *   Создать корневой `vnode`, привязанный к кластеру `BPB_RootClus`.
2.  **`lookup` (поиск файла)**:
    *   Читать кластеры директории последовательно.
    *   Парсить 32-байтные дескрипторы.
    *   Игнорировать удаленные (`0xE5`) и LFN (`0x0F`) записи.
3.  **`read`**:
    *   Транслировать смещение файла в цепочку кластеров.
    *   Учитывать, что файл может быть фрагментирован.
4.  **`write` / `create`**:
    *   Поиск свободного кластера через FSInfo.
    *   Обновление FAT цепочки.
    *   Создание записи в директории.
    *   Обнуление нового кластера (security requirement), чтобы не "протекли" старые данные.
5.  **`unlink` (удаление)**:
    *   Пометить запись в директории как `0xE5`.
    *   Пройти по цепочке FAT и пометить все кластеры как `0x00000000`.
    *   Обновить FSInfo (`Free_Count++`).

## 8. Ограничения и Edge Cases

1.  **Размер файла**: Максимальный размер файла в FAT32 — **4 ГБ минус 1 байт** (2^32 - 1). Попытка расширить файл дальше должна возвращать ошибку `EFBIG`.
2.  **Корневая директория**: В FAT32 она может расти. Если кластер заполнен, драйвер должен выделить новый и продлить цепочку.
3.  **Атомарность**: Обновление FAT и директории не атомарно. При сбое питания возможна потеря кластеров (помечены как занятые, но не привязаны к файлу). `fsck` (или аналог) потребуется в будущем.