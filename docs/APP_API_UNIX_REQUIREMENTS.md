# Требования к AppAPI (UNIX-like)

Этот документ описывает спецификацию программного интерфейса приложений (AppAPI) для VLSMC, ориентированного на совместимость с философией UNIX и стандартом POSIX.

## 1. Общие принципы

### 1.1. "Всё есть файл"
Унифицированный интерфейс доступа к ресурсам. Файлы, устройства (character/block devices), каналы (pipes) и сокеты должны управляться через единый набор системных вызовов: `open`, `read`, `write`, `close`, `ioctl`.

### 1.2. Обработка ошибок
- Системные вызовы возвращают `-1` в случае ошибки.
- Код конкретной ошибки записывается в глобальную (или TLS) переменную `errno`.
- Коды ошибок должны соответствовать стандарту (EPERM, ENOENT, EINTR, etc.).

### 1.3. Стандартные потоки
При запуске процесса (через `exec`) должны быть открыты три файловых дескриптора:
- `0` (STDIN): Стандартный ввод.
- `1` (STDOUT): Стандартный вывод.
- `2` (STDERR): Стандартный вывод ошибок.

---

## 2. Файловый ввод-вывод (File I/O)

### 2.1. Базовые операции
- **`open(path, flags, mode)`**: Открытие файла. Флаги `O_RDONLY`, `O_WRONLY`, `O_RDWR`, `O_CREAT`, `O_APPEND`. Возвращает файловый дескриптор (FD).
- **`close(fd)`**: Закрытие дескриптора. Освобождение ресурса в ядре.
- **`read(fd, buf, count)`**: Чтение байт. Блокирующий вызов (по умолчанию).
- **`write(fd, buf, count)`**: Запись байт.
- **`lseek(fd, offset, whence)`**: Перемещение курсора чтения/записи (`SEEK_SET`, `SEEK_CUR`, `SEEK_END`).

### 2.2. Метаданные и Управление
- **`stat(path, buf)` / `fstat(fd, buf)`**: Получение информации о файле (размер, права, время модификации, тип).
- **`ioctl(fd, request, ...)`**: Управление параметрами устройства (например, смена видеорежима для `/dev/fb0` или настройка терминала `/dev/tty`).
- **`unlink(path)`**: Удаление файла (уменьшение счетчика ссылок на иноду).

---

## 3. Управление процессами (Process Management)

### 3.1. Жизненный цикл
- **`fork()`**: Создание копии текущего процесса (Copy-on-Write). Возвращает `0` ребенку и `PID` ребенка родителю.
- **`execve(path, argv, envp)`**: Замена образа текущего процесса новым.
- **`exit(status)`**: Завершение работы. Освобождение памяти, закрытие дескрипторов, отправка сигнала родителю.
- **`waitpid(pid, status, options)`**: Ожидание смены состояния дочернего процесса (завершение, остановка).

### 3.2. Идентификация
- **`getpid()`**: Получить свой ID.
- **`getppid()`**: Получить ID родителя.

---

## 4. Управление памятью (Memory Management)

### 4.1. Куча (Heap)
- **`brk(addr)` / `sbrk(increment)`**: Изменение границы сегмента данных (program break). Базовый механизм для реализации `malloc`.

### 4.2. Отображение памяти (Memory Mapping)
- **`mmap(addr, length, prot, flags, fd, offset)`**:
    - Отображение файлов в память.
    - Выделение анонимной памяти (флаг `MAP_ANONYMOUS`) для больших аллокаций.
- **`munmap(addr, length)`**: Освобождение отображенной памяти.

---

## 5. Межпроцессное взаимодействие (IPC)

### 5.1. Каналы (Pipes)
- **`pipe(fds[2])`**: Создание однонаправленного канала данных. `fds[0]` для чтения, `fds[1]` для записи.
- Используется для перенаправления ввода-вывода в шелле (`ls | grep foo`).

### 5.2. Сигналы (Signals)
- **`kill(pid, sig)`**: Отправка сигнала процессу.
- **`sigaction(sig, act, oldact)`**: Установка пользовательского обработчика сигнала.
- Основные сигналы: `SIGINT` (Ctrl+C), `SIGKILL` (безусловное завершение), `SIGSEGV` (ошибка памяти), `SIGCHLD` (смерть ребенка).

---

## 6. Пользователи и Права (Permissions)

- **UID / GID**: Идентификаторы пользователя и группы.
- **`chmod(path, mode)`**: Изменение прав доступа (rwx).
- **`chown(path, uid, gid)`**: Изменение владельца.
- Проверка прав при каждом доступе к файлу (VFS).

---

## 7. Реализация в VLSMC (Специфика)

- **Syscall Gate**: Использование прерывания `int 0x80`.
- **Регистры (i386)**: `EAX` (номер), `EBX`, `ECX`, `EDX`, `ESI`, `EDI` (аргументы).
- **Libc Wrapper**: Пользовательский код не должен вызывать `int 0x80` напрямую. Библиотека `libc.so` предоставляет C-функции (`open`, `read`...), которые настраивают регистры и делают вызов.