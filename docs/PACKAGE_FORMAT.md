# RAND Elecorner 36 — Формат исполняемых файлов

> Спецификация загрузчика формата ELF
> Build 0001

---

## Обзор

RAND Elecorner 36 больше не использует проприетарные `.vlsmc-pkg` (ZIP-архивы с JavaScript). Операционная система загружает и исполняет нативные 32-битные бинарники формата **ELF** (Executable and Linkable Format).

Все пользовательские приложения живут в Ring 3, изолируются через страничный механизм VMM (Virtual Memory Manager) и взаимодействуют с ядром ОС с помощью системных вызовов (Soft Interrupts `int 0x80`).

---

## Компиляция пользовательских программ

Кросс-компилятор `i686-elf-g++` (или `gcc` с флагом `-m32`) собирает пользовательский C/C++ исходный код в объектные файлы `*.o`. На этапе линковки эти объекты объединяются с небольшим рантаймом запуска (`user_crt0.o`) и библиотекой системных вызовов (`user_libc.a` / `libc.o`).

### Типовая структура пользовательского приложения

```cpp
// hello.cpp
#include <libc.h>

int main(int argc, char** argv) {
    printf("Привет, мир из Ring 3!\n");
    return 0; // Возвращает код завершения, который exit() передает ядру
}
```

```bash
# Компиляция программы
i686-elf-g++ -c hello.cpp -o hello.o -ffreestanding -O2 -Wall -Wextra

# Компоновка (Линковка)
i686-elf-ld -T user_linker.ld user_crt0.o hello.o libc.o -o HELLO.ELF
```

*Готовый бинарный файл `HELLO.ELF` затем копируется на загрузочный образ FAT16 (`data.img`).*

---

## ELF Loader Ядра (Загрузка в память)

Когда пользователь в оболочке Shell вводит команду `run HELLO.ELF`, происходит следующий процесс:

1. **Поиск файла:** Ядро ищет `HELLO.ELF` в корневом каталоге файловой системы (FAT16 на порту ATA).
2. **Чтение:** Файл считывается в буфер ядра целиком (или посекторно).
3. **Парсинг ELF:** Ядро читает заголовок `Elf32_Ehdr` и проверяет магическое число: `0x7F`, `'E'`, `'L'`, `'F'`. Убеждается, что файл собран под 32-битный x86 (`EM_386`) и является исполняемым (`ET_EXEC`).
4. **Создание Адресного Пространства:** Ядро создает новую пустую директорию страниц (Page Directory) для создаваемого процесса.
5. **Загрузка Сегментов (`Program Headers`):**
   Ядро перебирает заголовки программ (`Elf32_Phdr`) типа `PT_LOAD`:
   * Выделяются физические фреймы памяти с помощью PMM (Physical Memory Manager).
   * Выделенные фреймы маппируются (добавляются в таблицу страниц) по *виртуальному адресу* (Virtual Address / `p_vaddr`), указанному в заголовке программы (обычно начало секции `.text` располагается по адресу `0x40000000`).
   * Данные секций `.text` (код) и `.data` (проинициализированные переменные) копируются из файла загрузки во вновь созданную память.
   * Для неинициализированных данных (секция `.bss` / разница между `p_memsz` и `p_filesz`) выделяется память и обнуляется.
6. **Выделение Стека:** Выделяются фреймы для стека пользователя (Ring 3 Stack) по фиксированному виртуальному адресу (например, `0xBFFFF000`).
7. **Подготовка контекста и запуск (Switch to Ring 3):**
   * Планировщик создает новую структуру `Thread`/`TCB`.
   * В её контекст (Context) заносится стартовый виртуальный адрес `eip` (взятый из заголовка `e_entry` ELF-файла).
   * Устанавливается `cs` селектор для `USER_CODE_SEGMENT` и `ds` селекторы для `USER_DATA_SEGMENT` (значение `0x20 | 3 == 0x23` и `0x18 | 3 == 0x1B`).
   * Во время следующего тика таймера (или принудительного `switch_task()`) процессор выполнит инструкцию `IRETD`, которая загрузит User-сегменты, переключится в Ring 3 и начнёт выполнение программы по адресу точки входа.

---

## Стандартные виртуальные адреса (Ring 3)

| Диапазон Виртуальных Адресов | Назначение |
|-----------------------------|-----------|
| `0x00000000` — `0x3FFFFFFF` | Память Ядра (Supervisor Mode Only). Попытка доступа из Ring 3 вызовет Page Fault. |
| `0x40000000` — `0xBFFFFFFE` | Пространство пользователя (User Memory). Сюда грузится `.text` (Код), `.data`, `.rodata` и Heap. |
| `0xBFFFF000` — вниз        | Стек пользователя (User Stack, растет вниз). |

---

## Формирование точки входа (`user_crt0`)

Сам ELF-файл запускается не с функции `main()`, а со специальной ассемблерной заглушки или функции начальной загрузки `_start`.
Её задача — собрать параметры командной строки (в будущем) и инициировать стандартную библиотеку (libc), а затем уже вызвать `main`.

```cpp
// Пример user_crt0.cpp
extern "C" int main(int argc, char** argv);
extern "C" void exit(int code);

extern "C" void _start() {
    // В будущем здесь: настройка args, инициализация C++ глобальных конструкторов пользовательской библиотеки.
    int ret = main(0, nullptr);
    
    // По завершении main мы обязаны сказать ядру убить этот процесс. 
    // Если программа завершится "сама", процессор попытается выполнить мусор за концом файла.
    exit(ret); 
}
```
