# RAND Elecorner 36 — C++ Software Development Kit (Ring 3 API)

> Документация для разработчиков прикладного ПО и внешних драйверов
> Build 0001 (Bare-Metal OS)

---

## Обзор

Приложения для RAND Elecorner 36 пишутся на **C++17** (или **C**) и работают в пользовательском пространстве (User Space, Ring 3).

Для взаимодействия с аппаратным обеспечением, файловой системой и другими процессами программа использует системные вызовы. Вместо прямого вызова ассемблерного прерывания (`int 0x80`), прикладные разработчики используют оболочку — системную библиотеку `libc` (поставляется в `kernel/include/libc.h` и `user/libc.cpp`).

---

## Быстрый старт

### 1. Подключение SDK

В каждом C/C++ файле вашего приложения необходимо подключить главный заголовочный файл SDK:
```cpp
#include <libc.h>
```

Этот файл предоставляет обертки для:
- Консольного ввода/вывода (Console I/O)
- Управления процессами (Process Control)
- Управления памятью в куче (Heap Allocation) *(В разработке)*
- Межпроцессного взаимодействия (IPC) и Event Channels
- Работы с шиной (PCI Bus)

### 2. Пример: Простейшая программа

```cpp
// hello.cpp
#include <libc.h>

int main(int argc, char** argv) {
    printf("Добро пожаловать в RAND Elecorner 36!\n");
    printf("Система выполняет эту программу в Ring 3.\n");
    return 0; 
}
```

---

## API Системной Библиотеки (`libc`)

Все описанные функции транслируются в системные вызовы операционной системы (`read() -> Syscall 3`, `write() -> Syscall 4`, `exit() -> Syscall 1` и т.д.).

### `Консоль и Вывод (I/O)`

```cpp
// Вывод форматированной строки на экран (через ядерный VGA драйвер).
// Поддерживает %d, %x, %s, %c
int printf(const char* format, ...);

// Чтение одного символа с клавиатуры (Блокирующий вызов).
// Если в буфере пусто, процесс засыпает (переходит в состояние Waiting/Blocked) 
// до тех пор, пока пользователь не нажмет клавишу.
char getchar();
```

### `Управление процессами (Processes)`

```cpp
// Завершить текущий процесс с заданным кодом возврата (отдать CPU ядру).
void exit(int status);

// Добровольно отдать остаток текущего кванта времени CPU планировщику 
// и переключиться на следующую задачу в очереди (Сдвинуть Round-Robin).
void yield();
```

### `Шина PCI (Внешние Драйверы)`

Начиная с Build 0001, ОС поддерживает концепт внешних драйверов, работающих в Ring 3. Эти приложения могут отправлять системные вызовы `pci_read`, чтобы прочитать конфигурационное пространство конкретного устройства (например, сетевой карты). Ядро получает запрос, само делает потенциально опасный `outl` / `inl` (доступ к I/O портам) и безопасно возвращает 32-битное значение процессу.

```cpp
// Прочитать 32-битное слово (Dword) из конфигурационного пространства PCI устройства.
// Возвращает считанное значение.
uint32_t pci_read(uint8_t bus, uint8_t device, uint8_t func, uint8_t r);
```

### `Межпроцессное взаимодействие (IPC и Event Channels)`

В текущей модели ОС приложения обмениваются данными посредством блокирующих IPC каналов (Event Channels).

Один процесс ("Сервер" или "Драйвер") открывает канал и ждет событий. Когда приходит сообщение от "Клиента", Сервер просыпается, считывает данные и может продолжить работу.

```cpp
struct EventMessage {
    uint32_t event_type;
    uint32_t data1;
    uint32_t data2;
};

// Зарегистрировать/подключиться к каналу по короткому строковому имени (до 15 символов)
// Возвращает Channel ID (целое число), который в дальнейшем используется для send/recv.
int event_channel_open(const char* name);

// Отправить сообщение (структуру EventMessage) в канал с заданным ID.
// Если в канале уже накопилось максимальное количество необработанных сообщений, 
// отправитель может блокироваться (заснуть) до появления свободного места.
int event_channel_send(int channel_id, EventMessage* msg);

// Получить сообщение из канала (Блокирующий вызов).
// Если канал пуст, процесс переводится в состояние WAITING, 
// и не тратит CPU-циклы в цикле-пустышке, пока сообщение не придет.
int event_channel_receive(int channel_id, EventMessage* msg);
```

---

## Архитектура: Передача Syscall из Ring 3 в Ring 0

Функции в `libc.cpp` реализуют обертки над ассемблерными вставками. 
RAND Elecorner 36 использует классическое для старых x86 Linux программ программное прерывание `int 0x80`.

1. Библиотечная функция загружает **Номер системного вызова** в регистр `EAX` (например, для вызова `write` `EAX = 4`).
2. Аргументы вызова (строки, числа) загружаются в регистры `EBX`, `ECX`, `EDX`, `ESI`, `EDI`.
3. Выполняется инструкция `int 0x80`.
4. Процессор переключается из Ring 3 в Ring 0, подгружает системный стек (Stack 0) из TSS и прыгает в обработчик `syscall_gate`.
5. Ядро забирает аргументы из регистров, проверяет валидность указателей (что программа из Ring 3 не пытается читать/писать память ядра) и передает управление в `Syscalls::handle()`.
6. После выполнения `IRETD` процессор возвращается в код `libc` (Ring 3), и результат вызова находится в регистре `EAX`.

*Пример (Исходный код внутри libc):*
```cpp
void exit(int status) {
    int syscall_num = 1; // Syscall Exit
    __asm__ volatile (
        "mov %0, %%eax\n"
        "mov %1, %%ebx\n"
        "int $0x80\n"
        : // no outputs
        : "g"(syscall_num), "g"(status)
        : "eax", "ebx"
    );
    while (1); // Мы не должны вернуться сюда
}
```
