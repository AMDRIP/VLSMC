# TOP-10 критичных мест для исправления в первую очередь

Ниже — приоритетный список мест, которые дают наибольший риск по безопасности/стабильности и должны исправляться первыми.

## 1. Эскалация прав: любой ELF получает `is_driver=true`
- Где: `elf_exec()`.
- Почему критично: любой загруженный ELF получает привилегии драйвера (PIO/MMIO/IRQ), что ломает модель изоляции Ring3.
- Минимальный фикс: убрать auto-grant, оставить только whitelist/manifest-driven выдачу прав.

## 2. Ошибка политики MMIO в `sys_map_mmio`
- Где: `sys_map_mmio`.
- Почему критично: для `is_driver` сейчас доступ разрешается без проверки grant-диапазонов.
- Минимальный фикс: всегда проверять `allowed_mmio[]` (кроме строго ограниченного bootstrap-исключения).

## 3. Грубая модель DriverAPI через флаг `is_driver`
- Где: `sys_inb/outb/inw/outw`, `sys_wait_irq`, `sys_set_driver`.
- Почему критично: нет capability-гранулярности (порт/IRQ/диапазон), одна ошибка в policy = полный доступ.
- Минимальный фикс: capability tokens + revoke на cleanup.

## 4. VFS ABI-хак: `vnode*` возвращается как `int`
- Где: `vfs_open()` и использование в syscall-слое.
- Почему критично: риск UB/переполнений/разъезда ABI, усложнение безопасного управления lifetime.
- Минимальный фикс: нормальный контракт `file*`/fd без pointer-cast.

## 5. VFS не поддерживает реальные mountpoint-префиксы
- Где: `vfs_resolve_path` (жёстко `mount_points[0]`).
- Почему критично: расширение на несколько ФС/дисков фактически блокировано; возможны неверные резолвы пути.
- Минимальный фикс: выбрать superblock по самому длинному совпавшему mount-prefix.

## 6. Неконсистентные коды ошибок в syscalls
- Где: `sys_outb/sys_outw` возвращают `0` даже при запрете; часть API возвращает `-1`, часть `0`.
- Почему критично: user-space не может надёжно отличить success/failure, ошибки теряются.
- Минимальный фикс: единая negative errno-модель для всех driver-related syscalls.

## 7. Отсутствие timeout/error surface в ожидании IRQ
- Где: `sys_wait_irq` + user-driver loops.
- Почему критично: зависания драйвера в вечном ожидании и непрозрачные deadlock-сценарии.
- Минимальный фикс: `wait_irq(irq, timeout_ms)` + диагностируемые коды таймаута.

## 8. Busy-wait без явного результата в PS/2 драйвере
- Где: `PS2Driver::wait_read/write`.
- Почему критично: функции "молча" выходят по timeout, а вызывающий код продолжает I/O как будто всё ок.
- Минимальный фикс: возвращать статус/ошибку, пробрасывать в `init/read/write`.

## 9. Shell запускается как driver-thread
- Где: `kernel_main` выставляет `threads[shell_tid].is_driver = true`.
- Почему критично: CLI-процесс получает повышенные привилегии по умолчанию; высокий blast radius.
- Минимальный фикс: убрать broad privilege, выдавать только минимальные capabilities.

## 10. `sys_set_driver` без строгой trust-цепочки
- Где: `sys_set_driver`.
- Почему критично: при компромете одного driver-thread можно массово повышать привилегии другим потокам.
- Минимальный фикс: policy check (manifest owner/signature/ACL) + аудит вызовов.

---

## Рекомендуемый порядок внедрения (коротко)
1) Пункты 1+2+9 (быстрое снижение риска эскалации).
2) Пункты 3+6+7 (формализация API и ошибок).
3) Пункты 4+5 (архитектурная чистка VFS).
4) Пункты 8+10 (драйверная надёжность и trust policy).
