# Проектирование аллокатора кучи (User-Space)

В ответ на вопрос о том, как реализовать полноценный `malloc/free` в пользовательском пространстве (Ring 3) для сложных компонентов, вроде сетевых драйверов. Текущая реализация `vlsmc::App::malloc()` просто линейно сдвигает границу [sys_sbrk](file:///y:/DEV/VLSMC/kernel/src/syscall_gate.cpp#298-362) вперед, а [free()](file:///y:/DEV/VLSMC/user/app_api.h#75-88) способен освободить память, только если это был самый последний выделенный блок. Это неизбежно приведет к утечкам памяти (Out of Memory) при длительной работе драйвера.

Нам необходимо реализовать алгоритм, который умеет переиспользовать освобожденные (но не крайние) блоки памяти (Memory Recycling). 

## Выбор алгоритма
Для ОС подобного рода (где важна простота и понятность кода без сильного ущерба производительности) отлично подойдет реализация **First-Fit алгоритма со связным списком свободных блоков (Free List Manager)**, аналогичный подходу классического K\u0026R [malloc](file:///y:/DEV/VLSMC/user/app_api.h#60-74) или `dlmalloc`.

## Концепция реализации

### 1. Заголовки блоков (Block Metadata)
Каждый выделенный (и свободный) блок памяти должен предваряться небольшим мета-заголовком (обычно 8-16 байт). 
```cpp
struct MemBlock {
    size_t size;         // Размер блока (вкл. заголовок)
    bool is_free;        // Флаг свободы
    MemBlock* next;      // Указатель на следующий блок в куче (или списке свободных)
    MemBlock* prev;      // Опционально: Указатель на предыдущий (для быстрого слияния)
    
    // Смысловая нагрузка:
    uint32_t magic;      // Magic number (например, 0xDEADC0DE) для детекта Heap Corruption
};
```

### 2. Механика работы [malloc(size)](file:///y:/DEV/VLSMC/user/app_api.h#60-74)
1. **Выравнивание:** Размер запрашиваемой памяти + `sizeof(MemBlock)` выравнивается до кратного 4 или 8 байтам.
2. **Поиск:** Мы проходим по списку `MemBlock` (от начала кучи). Ищем первый блок (First-Fit), у которого `is_free == true` и `size >= (запрошенный размер)`.
3. **Разбиение (Splitting):** Если найденный свободный блок *сильно* больше запрашиваемого (например, нашли блок на 4096 байт, а нужно 32), мы "отпиливаем" от него нужный кусок, создавая новый `MemBlock` заголовок в середине, который помечается как свободный.
4. **Увеличение кучи (sbrk):** Если свободного блока подходящего размера нет, мы вызываем ядерный [sys_sbrk()](file:///y:/DEV/VLSMC/kernel/src/syscall_gate.cpp#298-362) на величину запрашиваемого блока (или больше, например +4KB, чтобы не дергать syscall на каждый [malloc](file:///y:/DEV/VLSMC/user/app_api.h#60-74) по 10 байт). Из новой памяти формируется `MemBlock`.
5. Помечаем блок `is_free = false` и возвращаем пользователю указатель [(void*)(block + 1)](file:///y:/DEV/VLSMC/user/libc/src/stdlib.cpp#94-105).

### 3. Механика работы [free(ptr)](file:///y:/DEV/VLSMC/user/app_api.h#75-88)
1. Отступаем от [ptr](file:///y:/DEV/VLSMC/kernel/src/cow.cpp#19-23) назад на `sizeof(MemBlock)` и получаем указатель на заголовок блока.
2. Проверяем `magic` (если используется). Если не совпадает — паника/авборт процесса (Heap Corruption).
3. Устанавливаем `is_free = true`.
4. **Слияние (Coalescing):** 
    - Проверяем следующий блок `next`. Если он тоже свободен — сливаем их в один большой блок (объединяем размеры, меняем указатели).
    - То же самое с предыдущим блоком `prev` (если он есть).
5. **Сужение кучи:** Если в результате слияния мы получили огромный пустой блок **в самом конце** нашей кучи, мы вызываем [sys_sbrk(-размер)](file:///y:/DEV/VLSMC/kernel/src/syscall_gate.cpp#298-362) чтобы вернуть память ядру.

## Следующие шаги для ядра VLSMC
1. Ядро уже поддерживает расширение/сужение кучи: [sys_sbrk(int increment)](file:///y:/DEV/VLSMC/kernel/src/syscall_gate.cpp#298-362) работает корректно (и даже освобождает `VMM::unmap_page` и физические фреймы при отрицательном инкременте).
2. Вся эта логика должна быть написана исключительно в [user/libc/src/malloc.cpp](file:///y:/DEV/VLSMC/user/libc/src/malloc.cpp) и `vlsmc::App` без какого-либо вмешательства в ядро ОС.

Если необходимо, мы можем разработать эту подсистему прямо сейчас.
