# Технические требования: Реализация fork() и exec()

Документ описывает требования к реализации классических системных вызовов управления процессами в VLSMC для обеспечения POSIX-совместимости.

## 1. Системный вызов fork()

Механизм создания точной копии текущего процесса.

### 1.1. Копирование адресного пространства (Copy-on-Write)
- **Изоляция**: Новый процесс (Child) должен получить идентичное виртуальное адресное пространство, но физически изолированное от родителя (Parent).
- **Оптимизация CoW**: 
    - Не копировать все физические страницы сразу.
    - Пометить страницы обоих процессов как "только для чтения" (Read-Only) и создать записи в таблицах страниц.
    - При попытке записи генерировать Page Fault, в обработчике которого ядро выделит новую физическую страницу и скопирует данные.
- **Общие ресурсы**: Дескрипторы открытых файлов и каналы IPC должны наследоваться и увеличивать счетчик ссылок.

### 1.2. Контекст исполнения
- **Регистры**: Копирование всех регистров общего назначения.
- **Возвращаемое значение**: 
    - В родителе `fork()` возвращает PID ребенка.
    - В ребенке `fork()` возвращает `0`.
- **Стек**: Копирование состояния стека ядра и пользовательского стека.

## 2. Системный вызов exec()

Механизм замещения текущего процесса новым исполняемым образом (ELF).

### 2.1. Загрузка образа
- **Парсинг ELF**: Чтение заголовка ELF, проверка Magic Number и архитектуры (x86 32-bit).
- **Очистка памяти**: Полное освобождение текущего пользовательского адресного пространства (кроме стека ядра).
- **Маппинг секций**: Загрузка секций `.text`, `.data` и обнуление `.bss` в соответствии с программными заголовками (Program Headers) ELF-файла.

### 2.2. Аргументы и окружение
- **Передача `argc`/`argv`**: Подготовка стека нового процесса. Аргументы должны быть скопированы из адресного пространства старого процесса в новое перед его окончательным уничтожением или через временный буфер ядра.
- **Точка входа**: Установка регистра `EIP` на адрес, указанный в заголовке ELF (`e_entry`).

## 3. Взаимодействие и жизненный цикл

### 3.1. Wait и Зомби-процессы
- **Завершение**: При вызове `sys_exit` процесс переходит в состояние `ZOMBIE`. Ресурсы (память) освобождаются, но структура в таблице процессов сохраняется для передачи кода возврата.
- **Wait**: Родитель должен иметь возможность вызвать `sys_wait`, чтобы получить код завершения ребенка и окончательно удалить его из таблицы процессов.

### 3.2. Безопасность
- **Разграничение прав**: Ребенок наследует полномочия (`Permissions`) родителя, если иное не указано при `exec` (механизм SUID пока не рассматривается).
- **Атомарность**: Операции создания процесса должны быть атомарными относительно планировщика, чтобы избежать состояния гонки.

## 4. Ограничения и риски
- **Дедлоки**: При копировании структур ядра, защищенных мьютексами, необходимо соблюдать порядок блокировок.
- **Память**: `fork()` требует наличия свободных структур для таблиц страниц. При нехватке памяти вызов должен возвращать ошибку и не изменять состояние родителя.
