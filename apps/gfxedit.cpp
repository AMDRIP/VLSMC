#include "app_api.h"
#include "vesa_driver.h"

extern "C" void __cxa_pure_virtual() {
    vlsmc::App::print("Pure virtual function call!\n");
    vlsmc::App::exit(1);
}

using namespace vlsmc;

namespace {

// Public-domain style 8x8 ASCII font (0..127)
static const uint8_t FONT8X8[128][8] = {
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},{0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00},
{0x36,0x36,0x24,0x00,0x00,0x00,0x00,0x00},{0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00},
{0x18,0x3E,0x03,0x1E,0x30,0x1F,0x18,0x00},{0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00},
{0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00},{0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00},
{0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00},{0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00},
{0x00,0x66,0x3C,0x7F,0x3C,0x66,0x00,0x00},{0x00,0x0C,0x0C,0x3F,0x0C,0x0C,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x06},{0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00},
{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00},{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00},
{0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00},{0x0C,0x0E,0x0C,0x0C,0x0C,0x0C,0x3F,0x00},
{0x1E,0x33,0x30,0x1C,0x06,0x33,0x3F,0x00},{0x1E,0x33,0x30,0x1C,0x30,0x33,0x1E,0x00},
{0x38,0x3C,0x36,0x33,0x7F,0x30,0x78,0x00},{0x3F,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00},
{0x1C,0x06,0x03,0x1F,0x33,0x33,0x1E,0x00},{0x3F,0x33,0x30,0x18,0x0C,0x0C,0x0C,0x00},
{0x1E,0x33,0x33,0x1E,0x33,0x33,0x1E,0x00},{0x1E,0x33,0x33,0x3E,0x30,0x18,0x0E,0x00},
{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00},{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x06},
{0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x00},{0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00},
{0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00},{0x1E,0x33,0x30,0x18,0x0C,0x00,0x0C,0x00},
{0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00},{0x0C,0x1E,0x33,0x33,0x3F,0x33,0x33,0x00},
{0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00},{0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00},
{0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00},{0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00},
{0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00},{0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00},
{0x33,0x33,0x33,0x3F,0x33,0x33,0x33,0x00},{0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},
{0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00},{0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00},
{0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00},{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00},
{0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00},{0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00},
{0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00},{0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00},
{0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00},{0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00},
{0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},{0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00},
{0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00},{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00},{0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00},
{0x7F,0x73,0x19,0x0C,0x26,0x63,0x7F,0x00},{0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00},
{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00},{0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00},
{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00},{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
{0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00},{0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00},
{0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00},{0x00,0x00,0x1E,0x33,0x03,0x33,0x1E,0x00},
{0x38,0x30,0x30,0x3E,0x33,0x33,0x6E,0x00},{0x00,0x00,0x1E,0x33,0x3F,0x03,0x1E,0x00},
{0x1C,0x36,0x06,0x0F,0x06,0x06,0x0F,0x00},{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F},
{0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00},{0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00},
{0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1E},{0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00},
{0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00},{0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00},
{0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00},{0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00},
{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F},{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78},
{0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00},{0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00},
{0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00},{0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00},
{0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00},{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00},
{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00},{0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F},
{0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00},{0x38,0x0C,0x0C,0x07,0x0C,0x0C,0x38,0x00},
{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00},{0x07,0x0C,0x0C,0x38,0x0C,0x0C,0x07,0x00},
{0x6E,0x3B,0x00,0x00,0x00,0x00,0x00,0x00},{0,0,0,0,0,0,0,0},

// Remaining control chars 96..127 unused fallback to empty/simple
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},
{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0}
};

static const int SCREEN_W = 1024;
static const int SCREEN_H = 768;
static const int CHAR_W = 8;
static const int CHAR_H = 8;

static const int TOP_BAR_H = 20;
static const int STATUS_H = 20;
static const int TEXT_X = 8;
static const int TEXT_Y = TOP_BAR_H + 4;
static const int TEXT_W = (SCREEN_W - 16) / CHAR_W;
static const int TEXT_H = (SCREEN_H - TOP_BAR_H - STATUS_H - 8) / CHAR_H;

static const int MAX_TEXT = 128 * 1024;
static char text_buf[MAX_TEXT];
static int text_len = 0;
static int cursor = 0;
static int view_line = 0;
static bool modified = false;
static const char* FILE_PATH = "/EDIT.TXT";

void mem_move(char* dst, const char* src, int n) {
    if (n <= 0 || dst == src) return;
    if (dst < src) {
        for (int i = 0; i < n; i++) dst[i] = src[i];
    } else {
        for (int i = n - 1; i >= 0; i--) dst[i] = src[i];
    }
}

int str_len(const char* s) {
    int n = 0;
    while (s && s[n]) n++;
    return n;
}

void fill_rect(uint32_t* fb, int x, int y, int w, int h, uint32_t color) {
    if (x < 0) { w += x; x = 0; }
    if (y < 0) { h += y; y = 0; }
    if (x + w > SCREEN_W) w = SCREEN_W - x;
    if (y + h > SCREEN_H) h = SCREEN_H - y;
    if (w <= 0 || h <= 0) return;

    for (int yy = 0; yy < h; yy++) {
        for (int xx = 0; xx < w; xx++) {
            fb[(y + yy) * SCREEN_W + (x + xx)] = color;
        }
    }
}

void draw_char(uint32_t* fb, int cx, int cy, char ch, uint32_t fg, uint32_t bg) {
    uint8_t idx = (uint8_t)ch;
    const uint8_t* g = FONT8X8[idx];
    int px = TEXT_X + cx * CHAR_W;
    int py = TEXT_Y + cy * CHAR_H;

    for (int y = 0; y < 8; y++) {
        uint8_t bits = g[y];
        for (int x = 0; x < 8; x++) {
            bool on = (bits & (1u << x)) != 0;
            fb[(py + y) * SCREEN_W + (px + x)] = on ? fg : bg;
        }
    }
}

void draw_text(uint32_t* fb, int px, int py, const char* s, uint32_t fg, uint32_t bg) {
    int x = px;
    for (int i = 0; s[i]; i++) {
        uint8_t idx = (uint8_t)s[i];
        const uint8_t* g = FONT8X8[idx];
        for (int y = 0; y < 8; y++) {
            uint8_t bits = g[y];
            for (int xx = 0; xx < 8; xx++) {
                bool on = (bits & (1u << xx)) != 0;
                fb[(py + y) * SCREEN_W + (x + xx)] = on ? fg : bg;
            }
        }
        x += 8;
    }
}

void index_to_linecol(int idx, int& line, int& col) {
    line = 0;
    col = 0;
    for (int i = 0; i < idx && i < text_len; i++) {
        if (text_buf[i] == '\n') { line++; col = 0; }
        else col++;
    }
}

int linecol_to_index(int target_line, int target_col) {
    int line = 0;
    int col = 0;
    for (int i = 0; i < text_len; i++) {
        if (line == target_line && col == target_col) return i;
        if (text_buf[i] == '\n') {
            if (line == target_line) return i;
            line++; col = 0;
        } else {
            col++;
        }
    }
    return text_len;
}

void ensure_cursor_visible() {
    int line, col;
    index_to_linecol(cursor, line, col);
    if (line < view_line) view_line = line;
    if (line >= view_line + TEXT_H) view_line = line - TEXT_H + 1;
    if (view_line < 0) view_line = 0;
}

void insert_char(char c) {
    if (text_len >= MAX_TEXT - 1) return;
    mem_move(text_buf + cursor + 1, text_buf + cursor, text_len - cursor);
    text_buf[cursor] = c;
    cursor++;
    text_len++;
    modified = true;
}

void backspace_char() {
    if (cursor <= 0) return;
    mem_move(text_buf + cursor - 1, text_buf + cursor, text_len - cursor);
    cursor--;
    text_len--;
    modified = true;
}

void delete_char() {
    if (cursor >= text_len) return;
    mem_move(text_buf + cursor, text_buf + cursor + 1, text_len - cursor - 1);
    text_len--;
    modified = true;
}

bool load_file() {
    int fd = App::open(FILE_PATH, FMODE_READ);
    if (fd < 0) {
        text_len = 0;
        cursor = 0;
        modified = false;
        return false;
    }

    int got = App::read(fd, text_buf, MAX_TEXT - 1);
    App::close(fd);

    if (got < 0) {
        text_len = 0;
        cursor = 0;
        modified = false;
        return false;
    }

    text_len = got;
    cursor = 0;
    modified = false;
    return true;
}

bool save_file() {
    int fd = App::open(FILE_PATH, FMODE_WRITE);
    if (fd < 0) return false;
    int wr = App::write(fd, text_buf, (uint32_t)text_len);
    App::close(fd);
    if (wr < 0) return false;
    modified = false;
    return true;
}

void draw_editor(uint32_t* fb, bool save_ok, bool loaded_ok) {
    fill_rect(fb, 0, 0, SCREEN_W, SCREEN_H, 0xFF101418);

    fill_rect(fb, 0, 0, SCREEN_W, TOP_BAR_H, 0xFF202A36);
    draw_text(fb, 8, 6, "GFXEDIT - Ctrl+S Save | ESC Quit | Arrows Move", 0xFFFFFFFF, 0xFF202A36);

    fill_rect(fb, 0, SCREEN_H - STATUS_H, SCREEN_W, STATUS_H, 0xFF202A36);
    draw_text(fb, 8, SCREEN_H - STATUS_H + 6, FILE_PATH, 0xFF8BE9FD, 0xFF202A36);
    draw_text(fb, 220, SCREEN_H - STATUS_H + 6, modified ? "[modified]" : "[saved]", modified ? 0xFFFFB86C : 0xFF50FA7B, 0xFF202A36);
    draw_text(fb, 340, SCREEN_H - STATUS_H + 6, loaded_ok ? "load:ok" : "load:new", 0xFFBD93F9, 0xFF202A36);
    draw_text(fb, 430, SCREEN_H - STATUS_H + 6, save_ok ? "save:ok" : "save:--", 0xFF50FA7B, 0xFF202A36);

    int cur_line = 0, cur_col = 0;
    index_to_linecol(cursor, cur_line, cur_col);

    int line = 0;
    int col = 0;
    int screen_line = 0;

    for (int i = 0; i <= text_len; i++) {
        bool end = (i == text_len);
        char ch = end ? '\0' : text_buf[i];

        if (line >= view_line && screen_line < TEXT_H) {
            if (!end && ch != '\n' && col < TEXT_W) {
                draw_char(fb, col, screen_line, ch, 0xFFE6E6E6, 0xFF101418);
            }
        }

        if (end || ch == '\n') {
            if (line >= view_line) screen_line++;
            line++;
            col = 0;
            if (screen_line >= TEXT_H) break;
        } else {
            col++;
        }
    }

    int cy = cur_line - view_line;
    if (cy >= 0 && cy < TEXT_H && cur_col >= 0 && cur_col < TEXT_W) {
        int px = TEXT_X + cur_col * CHAR_W;
        int py = TEXT_Y + cy * CHAR_H;
        fill_rect(fb, px, py + 7, 8, 1, 0xFFFFFF00);
    }
}

} // namespace

int main() {
    VesaDriver drv;
    DriverContext ctx{};
    if (drv.init(&ctx) != 0) {
        App::print("GFXEDIT: VESA init failed\n");
        return 1;
    }

    uint32_t* backbuffer = (uint32_t*)App::malloc(SCREEN_W * SCREEN_H * 4);
    if (!backbuffer) {
        App::print("GFXEDIT: Not enough memory for backbuffer\n");
        drv.stop(&ctx);
        return 1;
    }

    bool loaded_ok = load_file();
    bool save_ok = false;
    bool needs_redraw = true;

    while (true) {
        if (needs_redraw) {
            draw_editor(backbuffer, save_ok, loaded_ok);
            drv.seek(&ctx, 0);
            drv.write(&ctx, backbuffer, SCREEN_W * SCREEN_H * 4);
            needs_redraw = false;
        }

        char c = App::getchar();

        if (c == 27) { // ESC
            break;
        } else if (c == (char)0x80) { // UP
            int line, col; index_to_linecol(cursor, line, col);
            if (line > 0) cursor = linecol_to_index(line - 1, col);
        } else if (c == (char)0x81) { // DOWN
            int line, col; index_to_linecol(cursor, line, col);
            cursor = linecol_to_index(line + 1, col);
        } else if (c == (char)0x82) { // LEFT
            if (cursor > 0) cursor--;
        } else if (c == (char)0x83) { // RIGHT
            if (cursor < text_len) cursor++;
        } else if (c == (char)0x84) { // DELETE
            delete_char();
        } else if (c == 19) { // Ctrl+S
            save_ok = save_file();
        } else if (c == '\b' || c == 127 || c == 8) { // Backspace
            backspace_char();
        } else if (c == '\n' || c == '\r') {
            insert_char('\n');
        } else if (c >= 32 || c == '\t') {
            insert_char(c);
        }

        ensure_cursor_visible();
        needs_redraw = true;
    }

    App::free(backbuffer);
    drv.stop(&ctx);
    App::print("GFXEDIT: exit\n");
    return 0;
}
